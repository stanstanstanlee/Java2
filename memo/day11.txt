
[ (접근) 제어자 ] 자바는 공개정책 : 일반적으로 public 제어자 달고 함 
public ==>> 단순 연산자로( 외부로부터 )의 접근을 막고싶다면 private
private ==>> 해당 클래스 내부에서만 접근할 수 있다
	  "모든 멤버변수에게는 private을 설정"
	   + "getter, setter을 함께 생성"
	   ↓
외부에서 직접적으로 멤버변수의 값에 접근 할 수는 없으나,
getter,setter를 인지하고있으면 값을 바꿀수있다!
"캡슐화"와 연관이 많다

=================================================================

[ 추상 클래스 (abstract class) ] (표본)
Abstract classes cannot be instantiated, but they can be subclassed.
1. 객채화(인스턴스화) 불가능  
	생성자를 가질수있음에 유의!!
	new 연산자와 함께 사용 불가

2. 추상메서드를 소유할수있음 (여러개 가능)
	=> 오버라이딩을 "강제"
			=> 엄청좋은거다!하라는데로만 하면 되니까
					(프로젝트에 많이 넣어야지~)
	=> 메서드 바디{}<<=중괄호를 가질 수 없음 가질 수 없음 
			어차피 오버라이딩 해야 하니까
=========================================================		
자식의 생성자를 내가 제어 할 수 있는가(생성자컨트롤)

추상메서드 오버라이딩 할 수 있는가?

인자로 객체를 받는경우 해당 객체를 사용할 줄 아는가?  
=========================================================
제가 이렇게 하고 싶은데 이게 되요? 문법이 뭐에여?
=========================================================


class Player
   최대 3마리의 포켓몬을 소유할수있다.
   Player 생성시 최초 소지 포켓몬은 무조건 피카츄이다.
   final static int maxIndex=3;
   int preIndex; // 1
   Pokemon[] data; // new Pokemon[maxIndex]
   // data[0]=new 피카츄();
   void play()
      // data에 저장된 포켓몬을 랜덤으로 2마리 선택하여 게임을 진행
      // 단, 2마리의 포켓몬이 서로 같은 포켓몬이면 더이상 진행하지않음 [Object최상위클래스->equals() 오버라이딩]
               클래스 타입이 같으면 같은 포켓몬
      // 서로 다른 포켓몬이면 포켓몬.game()을 진행함
      // 이긴 포켓몬의 울음소리가 console에 출력됨
      // 포켓몬.hello()

class Pokemon [abstract]
   String name;
   int win; // 이긴횟수
   void hello() // 울음소리. 하위클래스에 따라 수행되는 기능이 다름에 유의 [오버라이딩 강제->추상메서드]
   boolean game(Pokemon pokemon)
      // win이 홀홀일때는 작은쪽이 이김
      // win이 짝짝일때는 큰쪽이 이김
      // win이 홀짝일때는 홀수가 이김
      // win이 동일하다면 주어(주체)가 이김
      // 이후 이긴쪽의 win이 1 증가



1. 포켓몬 추가
2. 가진 포켓몬 전체 출력
3. 게임시키기
4. 프로그램 종료
======================================================

class Player
   최대 3마리의 포켓몬을 소유할수있다.
   Player 생성시 최초 소지 포켓몬은 무조건 피카츄이다.
   final static int maxIndex=3;
   int preIndex; // 1
   Pokemon[] data; // new Pokemon[maxIndex]
   // data[0]=new 피카츄();
   void play()
      // data에 저장된 포켓몬을 랜덤으로 2마리 선택하여 게임을 진행
      // 단, 2마리의 포켓몬이 서로 같은 포켓몬이면 더이상 진행하지않음 [Object최상위클래스->equals() 오버라이딩]
               클래스 타입이 같으면 같은 포켓몬
      // 서로 다른 포켓몬이면 포켓몬.game()을 진행함
      // 이긴 포켓몬의 울음소리가 console에 출력됨
      // 포켓몬.hello()



복습을 하면 질문이 생길 수 밖에 없는데 질문을 안한다? 복습을 안하넹?

======================================================

INPUT : 나(기능을수행할주어)한테 있는데???? 그럼 없음 

======================================================

[ 객체지향 코딩 1부 ] 

1. 객체화 할때 this. 쓰는거 this() 바로 쓰는거

2. 객체배열 (걍 int 배열 처럼 생각하면됨)

3. 상속일때 super

4. private + getter, setter

5. 상속일때 오버라이딩 (메서드 재정의)

6. 멤버변수로 객체배열이 있는경우 

[ 추상화 ]
	설계에 필요한 클래스 (객체화되지 않는)
	abstract
[ 캡슐화 ] 
	내부로의 직접 접근을 막고 어떻게 쓰는지 알면 걍 허락
	private + getter, setter
[ 상속 ]
	extends
	
[ 다형성 ] 
	void play() {
	if(this.data[num1].equals(this.data[num2]))
		if(this.data[num1]. 얘가 equals()를 수행하는 주체 (주어)가 됨 
		   data타입==포켓몬 	equals는 피카츄,파이리 메타몽이 가진거임 
		   부모.메서드()했어도, 알아서 자식이구현한메서드가 실행되는 현상
		    == 동적바인딩 -> "다형성"이 실현되었다!
      // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
      // this.data[num1]가 equals()를 수행하는 주체(주어)
      // 타입==포켓몬      피카츄,파이리,메타몽,...
      // 부모.메서드()했어도, 알아서
      // 자식이구현한메서드가 실행되는 현상
      //  == 동적바인딩 -> "다형성"이 실현되었다!
         
         // ☆ 실제 equals()를 수행하는 주체(주어)가
         // 피카츄,파이리,꼬부기,...
					
	}

	A,B,C 객체가 동일한 기능을 수행했어도
	서로다른 효과가 나타나야할때
	=> 다형성을 실현시켜야하는구나~!! 
		티모가 Q하면 독침이 나가고
		하이가 Q하면 구슬이 나가는것임 

메서드 구현할때 
            // ☆ 기능을 개발할때에는 항상
            // "주어(주체)"가 누구인지?
            // "대상(인자)"가 누구인지?
============================================================================
코드리뷰받아야함








